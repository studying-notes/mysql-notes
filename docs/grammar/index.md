---
date: 2020-10-12 10:41:51+08:00  # 创建日期
author: "Rustle Karl"  # 作者

title: "索引"  # 文章标题
url:  "posts/mysql/docs/grammar/index"  # 设置网页永久链接
tags: [ "mysql", "idx" ]  # 标签
categories: [ "MySQL 学习笔记" ]  # 分类

toc: true  # 目录
draft: true  # 草稿
---

## 索引简介

索引（Index）是帮助 MySQL 高效获取数据的数据结构，它用于快速找出在某个列中含有某一特定值的行。

如果不使用索引，那么 MySQL 必须从第1条记录开始然后读完整个表直到找出相关的行。表越大、花费的时间越多。如果表中查询的列有一个索引，那么 MySQL 就能快速到达一个位置去搜寻数据文件，没有必要看所有数据。

索引在 MySQL 中也称为“键(key)”，是存储引擎用于快速找到记录的一种数据结构。总体来说，索引有如下几个优点：

1. 索引大大减少了服务器需要扫描的数据量。
2. 索引可以帮助服务器避免排序和临时表。
3. 索引可以将随机 I/O 变为顺序 I/O。

索引可以极大地提高数据的查询速度，但是会降低插入删除更新表的速度，因为在执行这些写操作时，还需要操作索引文件。

对已经建立了索引的表中插入数据时，插入一条数据就要对该记录按索引排序。因此，当导入大量数据的时候，速度会很慢。解决这种情况的办法是，在没有任何索引的情况插入数据，然后建立索引。

## 创建索引的三种方式

在执行CREATE TABLE时创建索引

```sql
CREATE TABLE `employee` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `date` datetime DEFAULT NULL,
  `sex` int(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

使用ALTER TABLE命令添加索引

```sql
ALTER TABLE table_name ADD INDEX index_name (column);
```

使用CREATE INDEX命令创建

```sql
CREATE INDEX index_name ON table_name (column);
```

## MySQL 中的索引分类

MySQL 的所有列类型都可以被索引。InnoDB 类型的表默认创建的都是 BTREE 索引；MEMORY 类型的表默认使用 HASH 索引，但是也支持 BTREE 索引；空间列类型的索引使用 RTREE（空间索引）。

MySQL 中的索引是在存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。MySQL 目前提供了以下几种索引。

1. BTREE 索引：最常见的索引类型，大部分引擎都支持 BTREE 索引，例如 InnoDB、MEMORY 等。
2. HASH 索引：只有 MEMORY 和 NDB 引擎支持，适用于简单场景。
3. RTREE 索引（空间索引）：空间索引，主要用于地理空间数据类型，通常使用较少。
4. FULLTEXT（全文索引）：全文索引。

MySQL 目前还不支持函数索引，但是支持前缀索引，即对索引字段的前 N 个字符创建索引，这个特性可以大大缩小索引文件的大小，从而提高性能。

但是，前缀索引在排序 ORDER BY 和分组 GROUP BY 操作的时候无法使用，也无法使用前缀索引做覆盖扫描。用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。

## MySQL 中索引的使用原则

索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提高索引的使用效率，更高效地使用索引。

1. 最适合索引的列是出现在 **WHERE 子句中的列**，或**连接子句中指定的列**，而不是出现在 SELECT 关键字后的选择列表中的列。

2. **使用唯一索引**。考虑某列中值的分布。**索引的列的基数越大，索引的效果越好**。**唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录**。例如，学生表中的学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。

3. **使用短索引**。如果对字符串列进行索引，那么应该**指定一个前缀长度**。例如，有一个 CHAR(200) 列，如果在前 10 个字符内，大多数值是唯一的，那么就不要对整个列使用索引。对前 10 个字符进行索引能够节省大量索引空间，也会使查询更快，因为较小的索引涉及的磁盘 I/O 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL 也可以在内存中容纳更多的值。

4. **利用最左前缀**。在创建一个 n 列的索引时，实际是创建了 MySQL 可利用的 n 个索引。多列索引可以起到多个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集被称为最左前缀（Leftmost Prefixing）。

5. 不要过度索引。不要以为索引“越多越好”，什么东西都用索引是错误的。因为**每个索引都要占用额外的磁盘空间**，并降低写操作的性能，增加维护成本。在修改表的内容时，索引必须进行更新，有时也可能需要重构，因此，索引越多，维护索引所花的时间也就越长。如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最好索引。只保持所需的索引有利于查询优化。

6. 对于 InnoDB 存储引擎的表，**记录默认按照一定的顺序保存**，如果有明确定义的主键，那么按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以 **InnoDB 表尽量自己指定主键**，当表中同时有几个列都是唯一的，都可以作为主键的时候，要**选择最常用作访问条件的列作为主键**，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以**主键要尽可能选择较短的数据类型**，可以有效地减少索引的磁盘占用，提高索引的缓存效果。

7. **为经常需要排序、分组和联合操作的字段建立索引**。经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。

8. **尽量使用数据量少的索引**。如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段进行检索需要的时间要多。

9. **尽量使用前缀来索引**。如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。

10. **删除不再使用或者很少使用的索引**。表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

## 唯一索引

普通索引允许被索引的数据列包含重复的值，如果能确定某个数据列只包含彼此各不相同的值，在为这个数据索引创建索引的时候就应该用关键字 UNIQE 把它定义为一个唯一索引，唯一索引可以保证数据记录的唯一性。

**主键是一种特殊的唯一索引**，在一张表中只能定义一个主键索引，逐渐用于唯一标识一条记录，是用关键字 PRIMARY KEY 来创建。

## 联合索引/复合索引

**索引可以覆盖多个数据列**，例如 INDEX 索引，这就是联合索引。

前导列是创建复合索引语句的第一列或者连续的多列。

比如，

```sql
CREATE INDEX idx ON table(x, y, z)
```

那么 x,xy,xyz 都是前导列，而 yz, y, z 这样的就不是。

当我们创建一个组合索引的时候，如 (k1, k2 ,k3)，相当于创建了（k1）、(k1, k2) 和 (k1, k2, k3) 三个索引，这就是最左匹配原则。

```sql
select * from table where k1=A AND k2=B AND k3=D 
```

有关于复合索引，我们需要关注查询条件的顺序，确保最左匹配原则有效，同时可以删除不必要的冗余索引。

## 覆盖索引

如果**一个索引包含所有满足查询所需要的数据**，那么就称这类索引为**覆盖索引**（Covering Index）。**索引覆盖查询不需要回表操作**。索引即是数据。

在 MySQL 中，可以通过使用 explain 命令输出的 Extra 列来判断是否使用了索引覆盖查询。若使用了索引覆盖查询，则 Extra 列包含“Using index””字符串。MySQL 查询优化器在执行查询前会判断是否有一个索引能执行覆盖查询。

**覆盖索引能有效地提高查询性能**，因为**覆盖索引只需要读取索引而不需要再回表读取数据**。覆盖索引有以下一些优点：

1. 索引项通常比记录要小，所以 MySQL 会访问更少的数据。
2. 索引都按值的大小顺序存储，相对于随机访问记录，需要更少的 I/O。
3. 大多数据引擎能更好地缓存索引。
4. 覆盖索引对于 InnoDB 表尤其有用，因为 InnoDB 使用聚集索引组织数据，如果二级索引中包含查询所需的数据，那么就不再需要在聚集索引中查找了。

## 哈希索引

哈希索引（Hash Index）建立在哈希表的基础上，它只对使用了索引中的每一列的精确查找有用。**对于每一行，存储引擎计算出了被索引的哈希码（Hash Code）**，它是一个较小的值，并且有可能和其他行的哈希码不同。它把哈希码保存在索引中，并且保存了一个指向哈希表中的每一行的指针。如果**多个值有相同的哈希码**，那么索引就会**把行指针以链表的方式保存在哈希表的同一条记录中**。

只有 MEMORY 和 NDB 两种引擎支持哈希索引，MEMORY 引擎默认支持哈希索引，如果多个 HASH 值相同，出现哈希碰撞，那么索引以链表方式存储。若要使 InnoDB 或 MyISAM支 持哈希索引，那么可以通过伪哈希索引来实现。主要通过增加一个字段，存储 HASH 值，将 HASH 值建立索引，在插入和更新的时候，建立触发器，自动添加计算后的 HASH 值到表里。在查询的时候，在 WHERE 子句手动指定使用哈希函数。这样做的缺陷是需要维护哈希值。

MySQL 最常用存储引擎 InnoDB 和 MyISAM 都不支持 HASH 索引，它们默认的索引都是 BTree。但是，如果在创建索引的时候定义其索引类型为 HASH，那么 MySQL 并不会报错，而且通过 `SHOW CREATE TABLE` 查看该索引也是 HASH，只不过该索引实际上还是 BTree。

HASH 索引检索效率非常高，索引的检索可以一次到位，不像 BTREE 索引需要从根节点到枝节点，最后才能访问到叶节点这样多次的 I/O 访问，所以 HASH 索引的查询效率要远高于 BTREE 索引。那么，既然 HASH 索引的效率要比 BTREE 高很多，为什么大家不都用 HASH 索引而还要使用 BTREE 索引呢？其实，任何事物都是有两面性的，HASH 索引也一样，虽然 HASH 索引效率高，但是 HASH 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下几个限制：

1. HASH 索引仅仅能满足“=”、“IN”和“<=>”查询，**不能使用范围查询**。由于 HASH 索引比较的是进行 HASH 运算之后的 HASH 值，所以它**只能用于等值的过滤，不能用于基于范围的过滤**，因为经过相应的 HASH 算法处理之后的 HASH 值的大小关系，并不能保证和 HASH 运算前完全一样。
2. 优化器不能使用 HASH 索引来加速 ORDER BY 操作，即 **HASH 索引无法被用来避免数据的排序操作**。由于 HASH 索引中存放的是经过 HASH 计算之后的 HASH 值，而且 HASH 值的大小关系并不一定和 HASH 运算前的键值完全一样，所**以数据库无法利用索引的数据来减少任何排序运算量**。
3. MySQL 不能确定在两个值之间大约有多少行。如果将一个 MylSAM 表改为 HASH 索引的 MEMORY 表，那么会影响一些查询的执行效率。
4. 只能使用整个关键字来搜索一行，即 HASH 索引不能利用部分索引键查询。对于组合索引，HASH 索引在计算 HASH 值的时候是组合索引键合并后再一起计算 HASH 值，而不是单独计算 HASH 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，HASH 索引也无法被利用。
5. HASH 索引在任何时候都不能避免表扫描。HASH 索引是将索引键通过 HASH 运算之后，将 HASH 运算结果的 HASH 值和所对应的行指针信息存放于一个 HASH 表中，由于不同索引键存在相同 HASH 值，所以即使取满足某个 HASH 键值的数据的记录条数，也无法从 HASH 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
6. HASH 索引遇到大量 HASH 值相等的情况后性能并不一定就会比 BTREE 索引高。对于选择性比较低的索引键，如果创建 HASH 索引，那么将会存在大量记录指针信息存于同一个 HASH 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，从而造成整体性能低下。

## 自适应哈希索引（Adaptive HashIndex）

InnoDB 引擎有一个特殊的功能称为自适应哈希索引（Adaptive Hash Index）。当 InnoDB 注意到**某些索引值被使用非常频繁时，它会在内存中基于 BTree 索引之上再创建一个哈希索引**，这样就让 BTree 索引也具有哈希索引的一些优点，例如：快速的哈希查找，这是一个全自动的，内部的行为，用户无法控制或者配置，不过如果有必要，可以选择关闭这个功能（`innodb_adaptive_hash_index=OFF`，默认为 ON）。

通过执行：

```sql
show engine innodb status;
```

可以看到自适应哈希索引的使用信息，包括自适应哈希索引的大小、使用情况，每秒使用自适应哈希索引搜索的情况。

## 前缀索引

有时候需要索引很长的字符列，这会让索引变得大且慢，此时可以考虑前缀索引。

前缀索引，即对索引字段的前N个字符创建索引，这个特性可以大大缩小索引文件的大小，从而提高索引效率。用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。前缀索引是一种能使索引更小、更快的有效办法。

前缀索引的缺点是，在排序 ORDER BY 和分组 GROUP BY 操作的时候无法使用，也无法使用前缀索引做覆盖扫描，并且前缀索引降低了索引的选择性。索引的选择性是指不重复的索引值（也称为基数，Cardinality）和数据表的记录总数（COUNT(*)）的比值，范围为(0,1]。索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。

一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

使用前缀索引的诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。换句话说，前缀的“基数”应该接近于完整的列的“基数”。

为了决定前缀的合适长度，需要找到最常见值的列表，然后和最常见的前缀列表进行比较。下面给出一种方法，计算完整列的选择性，并使其前缀的选择性接近于完整列的选择性。

## 全文（FULLTEXT）索引

使用 FULLTEXT 参数可以设置索引为全文索引。全文索引只能创建在 CHAR、VARCHAR 或 TEXT 类型的字段上。在查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。在默认情况下，**全文索引的搜索执行方式不区分大小写**。但是，当索引的列使用二进制排序后，可以执行区分大小写的全文索引。

MySQL 自带的全文索引**只能对英文进行全文检索**，目前无法对中文进行全文检索。

目前，在使用 MySQL 自带的全文索引时，如果查询字符串的长度过短，那么将无法得到期望的搜索结果。MySQL **全文索引所能找到的词默认最小长度为 4 个字符**，由参数 `ft_min_word_len` 控制。另外，如果查询的字符串包含停止词，那么该停止词将会被忽略。

如果可能，那么请尽量先创建表并插入所有数据后再创建全文索引，而不要在创建表时就直接创建全文索引，因为前者比后者的全文索引效率要高。

**全文索引的缺点**如下所示：

1. 数据表越大，全文索引效果好，比较小的数据表会返回一些难以理解的结果。
2. **全文检索以整个单词作为匹配对象**，单词变形、加上后缀或复数形式. ，就被认为是另一个单词。
3. 只有**由字母、数字、单引号、下划线构成的字符串被认为是单词**，带注音符号的字母仍是字母，像 `C++` 不再认为是单词。
4. 查询**不区分大小写**。
5. **全文索引创建速度慢**，而且对有全文索引的各种数据修改操作也慢。

### 创建全文索引的方式

#### 创建表的同时创建全文索引

```sql
create table article
(
    id    int auto_increment not null primary key,
    title varchar(200),
    body  text,
    FULLTEXT (title, body)
) engine = innodb;
```

#### 通过 alter table 的方式来添加

```sql
# ft_person_name 是索引名，可以随便取
alter table `person`
    add fulltext index ft_person_name (`name`);

alter table `person`
    add fulltext ft_person_name (`name`); 
```

#### 通过直接的方式

```sql
create fulltext index title_body
    on article (title, body);
```

也可以在创建索引的时候指定索引的长度：

```sql
create fulltext index title_body
    on article (title(20), body);
```

### 全文检索示例

```sql
create table article
(
    id      int(10) unsigned not null auto_increment,
    title   varchar(200) default null,
    content text,
    primary key (id),
    fulltext key title_content (title, content)
) engine = innodb
  default charset = utf8;

show create table article;
show index from article;
```

必须使用特有的语法才能使用全文索引进行查询，例如，想要在article表的title和content列中全文检索指定的查询字符串，可以按如下方式编写SQL语句：

```sql
select *
from article
where match(title, content) against('hello');
```

## 空间（SPATIAL）索引

使用 SPATIDX 参数可以设置索引为空间索引，这个所以可以被用作地理数据支持。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。 MySQL 中的空间数据类型包括 GEOMETRY 和 POINT 、 LINESTRING 和 POLYGON 等。而且索引的字段不能为空值。

## 索引未被使用的情况

1. **索引列出现了隐式类型转换**（Implicit Type Conversion）。常见的情况是，如果在 SQL 的 WHERE 条件中，字段类型为字符串，而其值为数值，那么 MySQL 不会使用索引，所以，**字符类型的字段值应该加上引号**。
2. 使用显式类型转换函数时，**字符集不一样**。
3. JOIN 查询关联的字段字符集不一样。
4. **WHERE 条件中含有 OR** ，除非 OR 条件中的所有列都是索引列。
5. **联合索引/多列索引没有使用前导列**。
6. 在 WHERE 子句中，**索引列所对应的值的第一个字符由通配符(WILDCARD)开始**，索引将不被采用，然而当通配符出现在字符串其他位置时，优化器就能利用索引。
7. MySQL 估计使用**全表扫描要比使用索引快**。
8. 对索引字段进行函数、算术运算或其他表达式(`!=` 或者 `<>`, `not in`,  `is null`， `is not null`)等操作。

## 索引不适合的场景

- 数据量少的不适合加索引
- 更新比较频繁的也不适合加索引
- 区分度低的字段不适合加索引（比如性别）
